\chapter{Related Work}

\label{chap:relwork}


\section{Overview}



In \cite{dias:automatic}, some considerations are made on how to compare CPU capacity in distributed systems. It also explains how changes in the CPU capacity affect the database. Regarding CPU virtualization, \cite{6127969} contains a study on its overhead. It provides a system to measure it and performs some experiments using as the Xen\footnote{http://xen.org} as the hypervisor. It shows that the overhead increases proportionally to the number of virtual machine guests deployed in a determined host. However, the CPU utilisation is improved, since reduces idle time. 

\cite{Soror:2008:AVM:1376616.1376711-OLD} shows how CPU costs should be modelled. It explains the process of building these cost models through information obtained from the DBMS and a way to dynamically schedule the CPU among the database workloads. \cite{Soror:2008:AVM:1376616.1376711-OLD} evolved to \cite{Soror:2008:AVM:1376616.1376711}, which is more detailed and discusses how multiple resources are scheduled. The latter serves as base for our paper, since it describes the virtualization design advisor, which will be detailed in the following section.

%Some papers discuss the cost of virtualizing DBMSes. \cite{4498282} shows an experimental study of the overhead of running a database workload in a virtual machine. In their experiments, they use Xen\footnote{http://xen.org} as the hypervisor and PostgreSQL\footnote{http://postgresql.org} as the DBMS. They show that although Xen does indeed introduce overhead for system calls, page fault handling and disk I/O, they are not translated to a high overhead in query execution times. The average overhead found was less than 10\%.  With a different perspective, \cite{Curino:2011:WDM:1989323.1989357} proposes its database consolidation solution, namely Kairos. While our solution is based on virtualization, in Kairos, each physical node runs a DBMS instance that processes transactions on behalf of multiple databases. They compare their solution to database virtualization. In their experiments for the virtualized alternative, each database runs on its own operating system, on top the VMware\footnote{http://vmware.com} 
%ESXi hypervisor. At the same request rate, it was shown that his solution has 6x to 12x higher throughput. Even though the results may reflect a huge disadvantage in virtualizing databases, in the virtualization tests the workloads are run in separate database servers, which incurs a significant amount of redundant work, like log writing. There is also a significant increase in the amount of context switches, due to the increased number of processes. The paper points out one specific virtualization problem that may have impacted on this result. It causes RAM to be allocated for multiple copies of the DBMS and the OS, which should be reduced by the hypervisor page sharing feature. However, in their experiments with VMware only a small amount of duplicated RAM was reclaimed.

%Regarding the resource allocation problem, \cite{Soundararajan:2009:DRA:1525908.1525914} proposes a multi-resource allocator that dynamically reallocates resources for database servers running on a virtual storage. Their aim is to proportionate the database, storage server caches and storage bandwidth among applications, according to performance goals. To achieve this, they built a performance model based on minimal statistics collection (  e.g. Trace of I/O access at the DBMS buffer pool and periodic sampling of the average disk latency ). Although they share a similar goal as  \cite{Soror:2008:AVM:1376616.1376711}, which serves as base for this paper, the approach is different. The former considers the interplay between different resources ( i.e. how changing one resource may affect the others ), while the latter treats them with a certain level of independence. Other difference is the information retrieved from the DBMS for each solution, \cite{Soundararajan:2009:DRA:1525908.1525914} uses very little 
%information from DBMS to 
%build its cost model. Thus ignoring that there is a whole cost model already built within the DBMS query optimizer. On the other hand,\cite{Soror:2008:AVM:1376616.1376711} is highly dependable on it, even though it may be inaccurate.
